#pragma kernel UpdateParticles

struct BaitData
{
	float3 currentPosition;
	float time;
};

float particleLifetime;
float particleSpeed;
float deltaTime;

float _CurrentFactor;

Texture3D MapTexture;

SamplerState samplerMapTexture;

RWStructuredBuffer<BaitData> particles;
RWStructuredBuffer<float3> baseVelocities;
RWStructuredBuffer<float4> particlePositions; //xyz = position, w = speed

float3 _StartingPoint;

[numthreads(128,1,1)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
	float time = particles[id.x].time + deltaTime;

	float positionReset = floor(time / particleLifetime); // 0 if time < lifetime, 1 if time > lifetime

	particles[id.x].time = time % particleLifetime;

	float3 uvs = lerp(particles[id.x].currentPosition, _StartingPoint, positionReset);

	float3 mapSample = MapTexture.SampleLevel(samplerMapTexture, uvs * .2, 0);
	mapSample = mapSample * 2 - 1;
	//mapSample = float3(0, mapSample.x, mapSample.y); 

	float3 currents = mapSample * deltaTime * particleSpeed;
	float3 diffusion = baseVelocities[id.x] * deltaTime * particleSpeed;
	float progression = time / particleLifetime;
	progression = pow(progression, _CurrentFactor);
	float3 offset = lerp(diffusion, currents, progression);
	offset *= 1 + progression;
	float3 newPos = (uvs + offset);

	particles[id.x].currentPosition = newPos;
	
	//float oldVelocity = particlePositions[id.x].w;
	//float newVelocity = length(mapSample);
	//newVelocity = lerp(oldVelocity, newVelocity, .1);
	float w = time / particleLifetime;
	particlePositions[id.x] = float4(particles[id.x].currentPosition, w);
}